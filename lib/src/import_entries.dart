import 'dart:convert';
import 'dart:io' as io;
import 'dart:typed_data';

import 'package:file/file.dart';
import 'package:file/local.dart';

import 'resource_importer.dart';
import 'utils.dart';

/// String tokens representing each of the supported resource types.
const _tokenUint8List = 'Uint8List';
const _tokenBase64Data = 'Base64Data';
const _tokenGzippedData = 'GzippedData';
const _tokenString = 'String';
const _tokenStringList = 'List<String>';

/// Abstract base class for imported resources.
abstract class ImportEntry {
  /// The variable name to use for the imported resource.
  late final String name;

  /// The string token for the resource type.
  late final String type;

  /// The path to the resource file.
  ///
  /// [path] might be relative to the YAML configuration file.
  String get path => _file.path;

  /// The resource file.
  late final File _file;

  /// Constructor that returns an appropriate subtype for [type].
  factory ImportEntry({
    required String name,
    required String path,
    String? type,
    FileSystem fs = const LocalFileSystem(),
  }) {
    var file = fs.file(fs.path.normalize(path));

    type ??= _tokenUint8List;

    ImportEntry entry;
    switch (type) {
      case _tokenUint8List:
        entry = Uint8ListImportEntry._();
        break;
      case _tokenBase64Data:
        entry = Base64DataImportEntry._();
        break;
      case _tokenGzippedData:
        entry = GzippedDataImportEntry._();
        break;
      case _tokenString:
        entry = StringImportEntry._();
        break;
      case _tokenStringList:
        entry = StringListImportEntry._();
        break;
      default:
        throw FormatException('Unrecognized type: $type');
    }
    return entry
      ..name = name
      ..type = type
      .._file = file;
  }

  ImportEntry._();

  @override
  String toString() => '$type: $name = "$path"';

  /// Any necessary Dart `import` statements that might be needed for the code
  /// generated by [generateCode].
  List<String> get requiredImports => const [];

  /// Generates code to declare a variable named [name] and that stores the
  /// contents of the file from [path].
  String generateCode();
}

/// Represents a resource imported as a [Uint8List].
class Uint8ListImportEntry extends ImportEntry {
  Uint8ListImportEntry._() : super._();

  @override
  List<String> get requiredImports => const ["import 'dart:typed_data';"];

  @override
  String generateCode() {
    // Uint8List is no const type, so we keep the raw data in a const int list and provide a load method
    // to retrieve the Uint8List. This is pretty efficient and avoids memory leaks as we dont keep the
    // Uint8List arround.
    var data = _file.readAsBytesSync();
    var stringBuffer = StringBuffer()
      ..write('const _$name = <int>[')
      ..writeln('// Do not format.');
    var count = 0;
    for (var byte in data) {
      var hex = byte.toRadixString(16).toUpperCase().padLeft(2, '0');
      stringBuffer.write('0x$hex, ');
      count += 1;
      if (count % 10 == 0) {
        stringBuffer.write('\n');
      }
    }
    stringBuffer
      ..writeln('];')
      ..write('Uint8List load')
      ..write(name.substring(0, 1).toUpperCase())
      ..write(name.substring(1))
      ..writeln('() => Uint8List.fromList(_$name);');

    return stringBuffer.toString();
  }
}

/// Represents a resource imported as a base64-encoded [String] literal.
class Base64DataImportEntry extends ImportEntry {
  Base64DataImportEntry._() : super._();

  @override
  List<String> get requiredImports =>
      const ["import 'package:$packageName/base64_data.dart';"];

  @override
  String generateCode() {
    var data = _file.readAsBytesSync();
    return 'const $name = Base64Data("${base64.encode(data)}");';
  }
}

/// Represents a resource imported as a gzip-compressed [Uint8List].
class GzippedDataImportEntry extends ImportEntry {
  GzippedDataImportEntry._() : super._();

  static const _gzipHeaderFileSystemByteIndex = 9;

  @override
  List<String> get requiredImports =>
      const ["import 'package:$packageName/gzipped_data.dart';"];

  @override
  String generateCode() {
    var data = _file.readAsBytesSync();
    var stringBuffer = StringBuffer()
      ..write('const $name = GzippedData([')
      ..writeln('// Do not format.');
    var count = 0;

    final encodedBytes = io.gzip.encode(data);
    if (encodedBytes.length > _gzipHeaderFileSystemByteIndex) {
      // by setting the gzip os byte to 255 (unknown operating system) we generate consistent headers
      // which is also important for unit testing.
      encodedBytes[_gzipHeaderFileSystemByteIndex] = 0xFF;
    }

    for (var byte in encodedBytes) {
      var hex = byte.toRadixString(16).toUpperCase().padLeft(2, '0');
      stringBuffer.write('0x$hex, ');
      count += 1;
      if (count % 10 == 0) {
        stringBuffer.writeln();
      }
    }
    stringBuffer.writeln(']);');
    return stringBuffer.toString();
  }
}

/// Represents a resource imported as a [String] literal.]
class StringImportEntry extends ImportEntry {
  StringImportEntry._() : super._();

  @override
  String generateCode() {
    var randomAccessFile = _file.openSync();
    Uint8List bom;
    try {
      bom = randomAccessFile.readSync(3);
    } finally {
      randomAccessFile.closeSync();
    }

    const utf8Bom = [0xEF, 0xBB, 0xBF];
    const utf16LeBom = [0xFF, 0xFE];
    const utf16BeBom = [0xFE, 0xFF];

    if (bom.startsWith(utf8Bom)) {
      // [File.readAsString] seems to ignore a UTF-8 BOM if present, so we
      // don't need to do anything extra.
    } else if (bom.startsWith(utf16LeBom)) {
      throw const FormatException('Unsupported encoding: UTF-16LE');
    } else if (bom.startsWith(utf16BeBom)) {
      throw const FormatException('Unsupported encoding: UTF-16BE');
    }

    final b = StringBuffer();

    // using lineSplitter ensures we convert `\r\n` to `\n` and also gives us the
    // opportunity to build the string up of multiple chunks, allowing for greater
    // readability with things such as text templates.
    final lines = _splitLines(_file.readAsStringSync());

    // if the string ends with a newline, we can avoid emitting the last line as it would be empty
    // and just ensure the `\n` is present end of the line before.
    final int lastEmittedIndex;
    final bool endsWithNewLine;
    if (lines.length > 1 && lines.last.isEmpty) {
      endsWithNewLine = true;
      lastEmittedIndex = lines.length - 2;
    } else {
      endsWithNewLine = false;
      lastEmittedIndex = lines.length - 1;
    }

    b.write('const $name = ');
    if (lastEmittedIndex > 0) {
      // more then one line, so let's add a linebreak before the first line to improve readability.
      b.writeln();
    }

    for (var lineIndex = 0; lineIndex <= lastEmittedIndex; lineIndex++) {
      final line = lines[lineIndex];
      b.write(' "');
      b.write(escapeString(line));
      if (lineIndex < lastEmittedIndex || endsWithNewLine) {
        b.write(r'\n');
      }
      b.write('"');
      if (lineIndex < lastEmittedIndex) {
        b.writeln();
      } else {
        b.writeln(';');
      }
    }

    return b.toString();
  }

  /// Dart's LineSplitter will not emmit the last empty line, but we dont want to loose anything
  /// from the file's contents, so we have to implement this ourselfes. We just want to convert
  /// all linebreaks to \n and emit individual strings for each line.
  ///
  /// Always returns at least one line.
  List<String> _splitLines(String fileContents) {
    const crCharCode = 13;
    const lfCahrCode = 10;

    var lines = <String>[];
    var end = fileContents.length;
    var sliceStart = 0;
    var char = 0;
    for (var i = 0; i < end; i++) {
      var previousChar = char;
      char = fileContents.codeUnitAt(i);
      if (char != crCharCode) {
        if (char != lfCahrCode) {
          continue;
        }
        if (previousChar == crCharCode) {
          sliceStart = i + 1;
          continue;
        }
      }
      lines.add(fileContents.substring(sliceStart, i));
      sliceStart = i + 1;
    }
    lines.add(fileContents.substring(sliceStart, end));
    return lines;
  }
}

/// Represents a resource imported as a [List] of [String] literals where
/// each literal represents a single line of text.
class StringListImportEntry extends ImportEntry {
  StringListImportEntry._() : super._();

  @override
  String generateCode() {
    var randomAccessFile = _file.openSync();
    Uint8List bom;
    try {
      bom = randomAccessFile.readSync(3);
    } finally {
      randomAccessFile.closeSync();
    }

    const utf8Bom = [0xEF, 0xBB, 0xBF];
    const utf16LeBom = [0xFF, 0xFE];
    const utf16BeBom = [0xFE, 0xFF];

    if (bom.startsWith(utf8Bom)) {
      // [File.readAsString] seems to ignore a UTF-8 BOM if present, so we
      // don't need to do anything extra.
    } else if (bom.startsWith(utf16LeBom)) {
      throw const FormatException('Unsupported encoding: UTF-16LE');
    } else if (bom.startsWith(utf16BeBom)) {
      throw const FormatException('Unsupported encoding: UTF-16BE');
    }

    var data = _file.readAsStringSync();
    var lines = LineSplitter.split(data);

    var stringBuffer = StringBuffer()..write('const $name = [');
    for (var line in lines) {
      stringBuffer.write('"${escapeString(line)}", ');
    }
    stringBuffer.write('];');
    return stringBuffer.toString();
  }
}
